# 순수 자바스크립트로 구현하기

## `window.requestAnimationFrame` 사용 이유는?

> 브라우저에게 수행하기를 원하는 애니메이션을 알리고 **다음 리페인트가 진행되기 전에** 해당 애니메이션을 업데이트하는 함수를 호출하게 합니다.

> "네가 다음에 나올 화면을 그릴 때, 나도 무언가를 그리고 싶기 때문에 이 함수도 실행시켜줘."

내가 이해한바를 적어본다. javascript를 이용하면 동적으로 CSS를 변경하거나 DOM을 변경할 수 있다. 그러면 브라우저가 그 사실을 인지하고 변경한다. 이 과정을 **리플로우**, **리페인팅**이라고 한다. 두 과정이 같이 일어나는건 아니고 사용 속성(CSS)에 따라 **리페인팅**만 읽어날 수도 있다. **리플로우와 리페인팅**을 쉽게 설명하자면 **리플로우**는 레이아웃 변경과 관련되었고 **리페인팅**은 레이아웃 변경없는 색상 변경을 의미한다. **리플로우와 리페인팅**은 성능과 관련된 부분이며 최소화하거나 최적화하는게 성능상 가장 좋다. 기본적으로 자바스크립트로 속성을 변경하면 그 즉시 **리플로우나 리페인팅**이 일어난다. 그런데 이 과정이 지속적으로 이뤄진다면 매우 비효율적일 것이다. 그래서 `requestAnimationFrame`를 사용하면 브라우저에게 함수 실행 권한을 의임하여 최적의 **리플로우와 리페인팅** 발생 시점에 내가 작성한 함수를 함께 처리해주기에 상대적으로 더 효율적이라는 것이다. 무분별하게 계속 리플로우와 리페인팅하는게 아니라 "내가 지금 리페인트와 리플로우를 처리할 예정인데. 너 `requestAnimationFrame`에 함수를 등록해두었구나? 그러면 내가 처리하는 김에 이 함수도 함께 처리해줄게~" 같으 느낌인 것이다.

모든 DOM 조작이나 애니메이션은 이 DOM API를 기반으로 해야한다. 이 콜백 내에서 DOM 작업을 수행하면 더 효율적이다. 이 API는 메인 스레드를 차단하지 않으며 다음 다시 그리기가 이벤트 루프에서 스케줄링되기 직전에 실행된다.

## `cloneNode` 사용 이유는?

> Node.cloneNode() 메서드는 이 메서드를 호출한 Node 의 복제된 Node를 반환합니다.

해당 node의 children까지 복제하려면 인자에 true를 해당 node만 복제하려면 false

## `replaceWith` 사용 이유는?

> 요소 교체

```js
var parent = document.createElement("div");
var child = document.createElement("p");
parent.appendChild(child);
var span = document.createElement("span");

child.replaceWith(span);

console.log(parent.outerHTML);
// "<div><span></span></div>"
```

## 복제한 노드에 변경하고 요소 교체를 해주는 이유

기존에 있는 요소를 직접 변경하는 것이 아닌 복제된 요소를 변경하고 있다. 복제된 요소를 변경하는 것이기에 원본은 영향을 받지 않는다. 원본을 바로 변경하면 수정 사항이 바로 바로 커밋 되지만 수정 사항을 한꺼번에 처리하고 한번만 교체를 해주는 방식으로 최적화한다.

## 작성한 예제의 플로우

1. 브라우저 렌더링
2. `requestAnimationFrame`
3. 다음 렌더링 대기
4. 새 가상 노드
5. replaceNode
6. DOM 조작
7. 브라우저 렌더링
